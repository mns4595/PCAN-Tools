import PCANBasic as pb
import time as tm
import threading
import tkinter
from datetime import datetime
# import psutil


###############################################################################
# Customizable section

# Folder location to store the recordings (USE UNIX STYLE DIRECTORY)
# ex: rootDir = "C:/Users/Iron Bird/Documents/Python CAN Recordings/"
rootDir = "C:/Users/Marco Nunez/Documents/Experimental/Python test files/"

# Base name of log file - Note that the date, time, and file extension will be
# appended to the end of your name of choice. The final name will look like
# the following example:
#     IronBird_Test_2021-12-03_14.36.05.737531.trc
#     [___________][_____________________________]
#        baseName         date/time/extension
baseName = "IronBird_Engine_Test"
###############################################################################


# Button Functions
def log_button_pressed(Button):
    global log_state, log_button

    if (log_state):
        print("\nLogging STOP. Click 'End Application' to close log file\n")
        log_button_text.set("Start Log")
        log_state = False
    else:
        print("\nLogging Started ...\n")
        log_button_text.set("Pause Log")
        log_state = True


def stop_button_pressed(Button):
    global close_file, tk

    print("Ending Application")
    close_file = True
    tk.destroy()


# PCAN Logging Function
def LogFrame():
    global pcan, pcan_handle, log_state, close_file

    start_time = 0

    # Message counter
    msg_count = 0
    # Start the error counter
    errors = 0
    # Store the current file size
    current_file_size = 0
    # Store the size of the file buffer currently in RAM
    file_size_on_ram = 0

    # File Name
    curr_time = list(str(datetime.now()))
    curr_time[10] = "_"
    curr_time[13] = "."
    curr_time[16] = "."

    curr_time = ''.join(curr_time)

    fName = baseName + "_" + curr_time + ".trc"

    # Open the log file
    f = open(rootDir + fName, "a")

    # Update file size
    current_file_size = f.tell()
    # Display warning if file is not empty
    if (current_file_size != 0):
        print("Selected file is NOT empty."
              + " Are you sure you want to append data to existing file?")

    wait_counter = 0
    # Wait for the module to start (i.e.: The clock is running)
    while start_time == 0:
        if (wait_counter % 300000 == 0):
            wait_counter = 0
            print("Waiting for PCAN Signal...")

        dumdum = pcan.Read(pcan_handle)
        start_time = dumdum[2].micros + 1000 * dumdum[2].millis + \
            int('0x100000000', 16) * 1000 * dumdum[2].millis_overflow

        wait_counter = wait_counter + 1

        if (close_file):
            break

    print("\nPCAN Signal Aquired!"
          + " -- Press 'Start Log' to beggin logging data\n\n")

    # timing for status print
    app_start_time = tm.perf_counter()
    curr_app_time = tm.perf_counter()
    prev_app_time = tm.perf_counter()

    # time for file header
    date = list(str(datetime.now()))
    month = ''.join(date[5:7])
    day = ''. join(date[8:10])
    year = ''.join(date[0:4])
    hour = ''.join(date[11::])

    stamp = month + "/" + day + "/" + year + " " + hour

    # Write file header
    f.write(";$FILEVERSION=1.1\n"
            + ";$STARTTIME=0.0\n"  # + str(app_start_time) + "\n"
            + ";\n"
            + ";   Start time: " + stamp + "\n"
            + ";   Generated by pcanLog.py v0.1\n"
            + ";\n"
            + ";   Message Number\n"
            + ";   |           Time Offset (ms)\n"
            + ";   |           |         Type\n"
            + ";   |           |         |       ID (hex)\n"
            + ";   |           |         |       |     Data Length\n"
            + ";   |           |         |       |     |   Data Bytes (hex)"
            + " ...\n"
            + ";   |           |         |       |     |   |\n"
            + ";---+---  ------+------  -+-  ----+---  +  -+ -- -- -- -- -- "
            + "-- --\n")

    # ------------------------------ Main Loop ------------------------------ #
    while(1):
        if (file_size_on_ram > 50000000):   # 50MB
            f.close()

            # Wait for file to close
            wakeup = tm.perf_counter() + 0.001  # 10ms

            while (tm.perf_counter() < wakeup):
                pass

            # reset file size counter
            file_size_on_ram = 0
            # open file to append
            f = open(rootDir + fName, "a")

        if ((curr_app_time - prev_app_time) > 5):
            print("Run Time: " + f'{(curr_app_time-app_start_time)/60:.2f}'
                  + "mins \tMessage Count: " + str(msg_count)
                  + " \tFile Size: " + str(current_file_size/1000) + "kB")

            curr_app_time = tm.perf_counter()
            prev_app_time = tm.perf_counter()
        else:
            curr_app_time = tm.perf_counter()

        if(close_file):
            f.close()
            break

        if (log_state):

            # We create a TPCANMsg message structure
            #
            CANMsg = pcan.Read(pcan_handle)

            # Parse the message elements
            errors = errors + CANMsg[0]
            msg = CANMsg[1]
            time = CANMsg[2]

            current_time = time.micros + 1000 * time.millis + \
                int('0x100000000', 16) * 1000 * time.millis_overflow

            # Use this for file printing
            if ((msg.ID != 0)):
                msg_count = msg_count + 1

                # -- count -- time -------- ID -- len
                s = "{:>7})  {:>13}  Rx   {:>8}  {:>1}  "

                # The +1 adds the '\n' that is appended at the end of each line
                _bytes = f.write(s.format(msg_count,
                                          (current_time-start_time)/1000.0,
                                          hex(msg.ID)[2:].upper(), msg.LEN))

                current_file_size = current_file_size + _bytes + 1
                file_size_on_ram = file_size_on_ram + _bytes + 1

                for i in range(0, msg.LEN):
                    _bytes = f.write(hex(msg.DATA[i])[2:].upper() + ' ')

                    current_file_size = current_file_size + _bytes
                    file_size_on_ram = file_size_on_ram + _bytes

                f.write("\n")
        else:
            tm.sleep(0.5)
    # ------------------------------ --------- ------------------------------ #

###############################################################################
#                                  INIT                                       #
###############################################################################


# ----------------------------- Button Objects ------------------------------ #
tk = tkinter.Tk()

log_state = False
close_file = False
safe_close = False
override = False

log_button_text = tkinter.StringVar()
log_button_text.set("Start Log")

log_button = tkinter.Button(
    tk,
    textvariable=log_button_text,
    width=25,
    height=5,
    bg="blue",
    fg="yellow"
)
stop_button = tkinter.Button(
    tk,
    text="End Application",
    width=25,
    height=5,
    bg="blue",
    fg="yellow"
)

log_button.bind("<ButtonPress>", log_button_pressed)
stop_button.bind("<ButtonPress>", stop_button_pressed)

log_button.pack(side=tkinter.LEFT)
stop_button.pack(side=tkinter.RIGHT)

# ------------------------------ PCAN Objects ------------------------------ #

# Initialize pcan object
pcan = pb.PCANBasic()
# Get PCAN Channel
pcan_handle = pb.PCAN_USBBUS1

# Setup Connection's Baud Rate
baudrate = pb.PCAN_BAUD_500K

result = pcan.Initialize(pcan_handle, baudrate)

if result != pb.PCAN_ERROR_OK:
    if result != pb.PCAN_ERROR_CAUTION:
        print("PCAN Error!")
    else:
        print('******************************************************')
        print('The bitrate being used is different than the given one')
        print('******************************************************')
        result = pb.PCAN_ERROR_OK
else:
    x = threading.Thread(target=LogFrame)
    x.start()

    print("Running PCAN Basic...")

    tk.mainloop()


print(".\n.\n.\nProgram Exit")
exit(0)
